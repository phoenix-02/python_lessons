# Урок 5
########
import sys # импортируем для начала встроенный модуль sys, который может дать нам более подробную информацию об ошибке
import pickle  # модуль pickle используется для сериализации данных
import json  # служит для создания json строки из словаря и обратно
import os # а этот модуль поможет нам вывести список файлов в папке

# Исключения в python
# Исключения - это еще один тип данных в python
# они служат для того, чтобы сообщать программисту об ошибках

# ниже примеры выбрасывания исключений
a, b = 10, 0
# print(a / b)  # если раскомментировать эту строку, то получим подобную ошибку-исключение
# Traceback (most recent call last):
#   File "/home/lexx/PycharmProjects/Lessons/lesson05.py", line 9, in <module>
#     print(a / b)
# ZeroDivisionError: division by zero
# показывает в каком файле произошло выбрасывание исключения, на какой именно строке и что за исключение
c, d = 1, '2'
# print(c + d)  # еще TypeError исключение при попытке конкатенировать строку с числом
# int('tupo stroka')  # ValueError исключение о невозможности приведения к числу заданной строки

# Самые распространенные типы исключений
# Exception – то, на чем фактически строятся все остальные ошибки;
# AttributeError – возникает, когда ссылка атрибута или присвоение не могут быть выполнены;
# IOError – возникает в том случае, когда операция I/O (такая как оператор вывода, встроенная функция open()
# или метод объекта-файла) не может быть выполнена, по связанной с I/O причине: «файл не найден», или «диск заполнен»,
# иными словами.
# ImportError – возникает, когда оператор import не может найти определение модуля, или когда оператор
# не может найти имя файла, который должен быть импортирован;
# IndexError – возникает, когда индекс последовательности находится вне допустимого диапазона;
# KeyError – возникает, когда ключ сопоставления (dictionary key) не найден в наборе существующих ключей;
# KeyboardInterrupt – возникает, когда пользователь нажимает клавишу прерывания(обычно Delete или Ctrl+C);
# NameError – возникает, когда локальное или глобальное имя не найдено;
# OSError – возникает, когда функция получает связанную с системой ошибку;
# SyntaxError — возникает, когда синтаксическая ошибка встречается синтаксическим анализатором;
# TypeError – возникает, когда операция или функция применяется к объекту несоответствующего типа.
# Связанное значение представляет собой строку, в которой приводятся подробные сведения о несоответствии типов;
# ValueError – возникает, когда встроенная операция или функция получают аргумент, тип которого правильный,
# но неправильно значение, и ситуация не может описана более точно, как при возникновении IndexError;
# ZeroDivisionError – возникает, когда второй аргумент операции division или modulo равен нулю;

# базово для обработки исключений служит конструкция try-except
# внутри блока try пишется код, исключения которого надо отлавливать
try:
    # diff = a / b
    diff2 = c + d
    # int('просто строка')
except ZeroDivisionError:  # сюда зайдет, только если выбросится исключение ZeroDivisionError
    print("делить на ноль нельзя")
except TypeError:  # сюда только если исключение будет TypeError
    print('разные типы данных')
except Exception as e:  # а Exception ловит все остальные типы исключений
# кстати, можно этот блок написать как просто except: но вообще такое общее условие отлова исключений лучше не использовать,
# конкретизирование того, какое исключение надо ловить помогает избежать неоднозначного поведения кода
    print('Произошло исключение', e)
    print(sys.exc_info()[0])  # тут мы использовали встроенный модуль sys чтобы получить информацию по последнему искл-ю


# a, b = 5, 2
try:  # ловим исключения в коде внутри этого блока
    diff = a / b
except:  # этот блок сработает, если внутри try произошло исключение
    print('Исключение брошено и поймано')
else:  # блок else: сработает только в том случае, если исключений не произошло
    print('Я исполнюсь, если исключение не выбрасывалось')
finally:  # а блок finally срабатывает всегда, вне зависимости от того, было ли исключение или нет
    print('я исполнюсь в любом случае в самом конце')


# Работа с файлами
filename = 'lesson05_data/test.txt'  # зададим строку с путем до файла
# путь может быть как относительный (смотря от местоположения файла с данным уроком)
# или же абсолютный, полный путь в системе, напр.
# c:/PythonLessons/files/test.txt или /home/lexx/PythonLessons/files/test.txt

# создаем список и превратим его содержимое в строку, используя for-in
somedata = [1, 3, 4, 5, 7, 9]
s = ''
for l in somedata:
    s += str(l) + '\n'  # прибавив к строке \n мы добавляем перевод на новую строку.

# файл открывается встроенной функцией open(), которая принимает два аргумента - имя файла и режим открытия
# при успешном открытии ф-я возвращает обработчик файла, объект, с помощью которого можно с этим файлом работать
# если файл по пути не найден, выбросится исключение FileNotFoundError
f = open(filename, 'w')  # передали в ф-ю путь до файла, режим w и присвоили результат открытия переменной f
f.write(s)  # используя полученный выше объект и его метод write() пишем в файл строку, созданную выше
f.close()  # обязательно закрываем файл после окончания работы с ним методом close()

# Режимы открытия файлов в python
# 'r'   открывает файл в режиме только для чтения. Начинает чтение с начала файла и является
# режимом по умолчанию для функции open ().
# 'rb'  открывает файл только для чтения в двоичном формате и начинает чтение с начала файла.
# Хотя двоичный формат можно использовать для разных целей, он обычно используется при работе с такими вещами, как
# изображения, видео и т.д.
# 'r+'  открывает файл для чтения и записи, помещая указатель в начало файла.
# 'w'   открывается в режиме только записи. Указатель помещается в начале файла, и это перезапишет любой существующий
# файл с тем же именем. Создаст новый файл, если файл с таким именем не существует.
# 'wb'  открывает файл только для записи в двоичном режиме.
# 'w+'  открывает файл для записи и чтения.
# 'wb+' открывает файл для записи и чтения в двоичном режиме.
# 'a'   открывает файл для добавления к нему новой информации. Указатель находится в конце файла.
# Новый файл создается, если файл с таким именем не существует.
# 'ab'  открывает файл для добавления в двоичном режиме.
# 'a+'  открывает файл для добавления и чтения.
# 'ab+' открывает файл для добавления и чтения в двоичном режиме.

# Чтение из файлов
f = open(filename)  # откроем файл, если режим не указывать, по умолчанию ставится режим на чтение - r
for line in f:  # мы можем просто итерировать по строкам открытого файла используя for-in, как со списками и тп
    print('===>',line.strip())  # печатаем строку, заюзаем метод строки strip() чтоб убрать пробелы и переводы строки
f.close()  # также, не забываем закрыть

# c помощью конструкции контекста with мы можем открывать файлы подобным образом:
# with open('путь_до_файла') as obrabotchik_fayla:
# Эта конструкция удобна тем, что она сама автоматом закроет файл после завершения кода в with
# Предпочтительно использовать ее при работе с файлами
with open(filename, 'r') as file_content:
    print('readline: ', file_content.readlines())
# метод readlines() обработчика файлов считывает все строки в файле
# метод readline() считывает одну строку в файле и двигает указатель на следующую
# Это значит, что при повторном вызове readline уже прочтет следующую строку
# метод read() считает весь файл целиком, также этому методу можно указать длину в байтах - read(1024) например

# запишем в файл что нибудь посложнее, например вот такой вот словарь
complex_dict = {
    'name': 'Ilyar',
    'surname': 'Sadikov',
    'cars': [
        {
            'model': 'ГАЗ-53',
            'year': 1980
        }, {
            'model': 'КРАЗ-83',
            'year': 1980
        }
    ]
}
# записывать сложные структуры данных в файлы в python можно с помощью двух модулей, pickle и json
# рассмотрим модуль pickle, который создает специальный бинарный файл pickle для записи данных

# зададим путь до файла
pickle_filename = 'lesson05_data/data.pickle'

# откроем файл на запись в бинарном режиме (wb), так как pickle не работает с текстовым режимом
with open(pickle_filename, 'wb') as f:
    # используем метод dump() модуля pickle чтобы записать данные в файл. В качестве аргументов передаем
    # первым сами данные, которые хотим сохранить, а вторым, обработчик файла, в который нужно записать данные
    pickle.dump(complex_dict, f)

# для чтения же pickle файла откроем файл на чтение в бинарном режиме (rb)
with open(pickle_filename, 'rb') as f:
    # читаем данные методом load(), который принимает обработчик файла, как аргумент и возвращает записанные данные
    loaded_data = pickle.load(f)  # передали обработчик f и записали результат в loaded_data
    print(loaded_data.get('name'))  # распечатываем прочитанные данные, видим, что в результате создался тот же словарь

# Также, для хранения данных можно использовать модуль json, который позволяет получать
# удобное текстовое json представление данных в файле, которое легко читается и человеком

# аналогично, путь до другого файла, где будем хранить json
json_filename = 'lesson05_data/data.json'

with open(json_filename, 'w') as f: # открываем файл на запись в обычном, текстовом режиме
    # с помощью метода dumps() модуля json создаем json-строку из того словаря, что мы выше объявили
    json_str = json.dumps(complex_dict)  # json_str - это теперь строка, которая содержит данные нашего словаря
    print(">>", json_str)  # посмотрим, как строка выглядит:
    # >> {"name": "Ilyar", "surname": "Sadikov", "cars": [{"model": "\u0413\u0410\u0417-53", "year": 1980}, {"model": "\u041a\u0420\u0410\u0417-83", "year": 1980}]}
    f.write(json_str)  # запишем полученную выше строку в открытый файл

with open(json_filename, 'r') as f:  # откроем файл на чтение
    file_content = f.read()  # считаем все содержимое файла в переменную методом read()
    # превратим считанную json строку в словарь методом loads() модуля json
    saved_dict = json.loads(file_content)  # передали строку - на выходе нормальный такой словарь
    print('Сохраненный словарь', saved_dict)  # принтанем и посмотрим
    # Сохраненный словарь {'name': 'Ilyar', 'surname': 'Sadikov', 'cars': [{'model': 'ГАЗ-53', 'year': 1980}, {'model': 'КРАЗ-83', 'year': 1980}]}

# ок, файлы читать-писать умеем, а теперь давайте разберем, как получить список файлов в папке
# для этого используется метод listdir модуля os, в который мы передаем путь к папке, которую надо считать
# на выходе получаем итератор со списком файлов и папок
directory = os.listdir('lesson05_data')

for file in directory:  # как мы обычно делаем со всеми итераторами - прочитаем содержимое по одному через for-in
    print('file: ', file)

# для пронумеровывания итераторов можно использовать ф-ю enumerate, подобным образом:
for index, file in enumerate(directory):
    print(index, ':', file)


# написать программу, которая запрашивает и сохраняет данные о пользователе в файл
# для каждого пользователя заводится отдельный файл, предварительно проверив, есть ли уже с таким именем
# у программы три режима работы - вывод всех файлов с пользователями; выбор файла и вывод данных;
# создание новой записи, путем введения новых данных;

