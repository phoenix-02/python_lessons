# # Урок 4
# ########

# Списки : Продолжение
# Список - это упорядоченный изменяемый набор значений любых типов
new_list = []  # пустой список
another_empty_list = list()  # еще пустой список
mylist = [6, 5, 7, 4, 6, 3, 9, 8, 777]  # список со значениями
# список с разными типами значений
complex_list = [1, 2, 'какая то строка', [1.2, 2.3, 5.6], False]
# список из строки или любого другого итератора можно создать так:
string_list = list('Список')
# и он будет выглядеть как ['С', 'п', 'и', 'с', 'о', 'к']
# У каждого элемента списка есть индекс
# у списка sp = [5, 8, 3, 2]
# будут индексы: 0, 1, 2, 3
print(complex_list[3][0])
# 1.2

# print(new_list, another_empty_list, complex_list)
# [] [] [1, 2, 'какая то строка', [1.2, 2.3, 5.6], False]

# С помощью in мы можем проверить наличие в списке определенного элемента например:
if 6 in mylist:  # True
    print("В mylist есть значение 6")

new_list.append(100500)  # Добавляет элемент в конец списка
new_list.extend(mylist)  # Расширяет список new_list, добавляя в конец все элементы списка mylist
new_list.insert(2, 'ПРИВЕТ')  # Вставляет на элемент с индексом 2 значение ПРИВЕТ
new_list.remove(
    'ПРИВЕТ123')  # Удаляет первый элемент в списке, имеющий заданное значение. ValueError,
# если такого элемента не существует

# Удаляет элемент с заданным индексом ( у нас 0) и возвращает его.
element = new_list.pop(0)
print('element: ', element)  # element: 100500
# Если индекс не указан, удаляется последний элемент
element2 = new_list.pop()
print('element2: ', element2)  # element2: 777

x = 3
new_list.index(x)  # Возвращает положение первого элемента со значением x
# можно задать границы поиска индекса, например newlist.index(x, 4, 8)
# при этом поиск будет вестись от 4 элемента включительно до 8 исключительно
pp = ['a', 'b', 'c', 'c', 'b', 'a']
x = pp.index('a')  # x будет равен 0
x = pp.index('a', 1, 6)  # x будет равен 5
# ValueError, если элемент с таким значением не найден

new_list.count(x)  # Возвращает количество элементов со значением x
new_list.clear()  # Очищает список

# сортировка элементов списка
print('До сортировки: ', new_list)  # [6, 5, 7, 4, 3, 9, 8]
new_list.sort()  # сортировка
print('После сортировки: ', new_list)  # [3, 4, 5, 6, 7, 8, 9]
new_list.sort(reverse=True)  # обратная сортировка
print('После обратной сортировки: ', new_list)  # [9, 8, 7, 6, 5, 4, 3]

new_list.reverse()  # Разворачивает список

# Копирование списков
new_list.copy()  # Поверхностная копия списка
# нужна для создания копии, потому что если делать копию обычным присвоением,
# то если менять первый список, второй тоже будет меняться. Например:
spis1 = ['a', 'b', 'c']  # создали первый список
spis2 = spis1  # потом решили создать копию этого списка в другой переменной
print('списки: ', spis1, spis2)  # списки:  ['a', 'b', 'c'] ['a', 'b', 'c']
spis1.append('hahaha')  # добавили элемент в первый список
# распечатали - а он и во втором списке оказался!
print('списки: ', spis1, spis2)  # ['a', 'b', 'c', 'hahaha'] ['a', 'b', 'c', 'hahaha']

# и чтоб такой фигни не происходило, используется метод copy(), который возвращает копию списка.
spis3 = spis1.copy()  # скопируем первый список в третий
print('списки: ', spis1, spis3)  # ['a', 'b', 'c', 'hahaha'] ['a', 'b', 'c', 'hahaha']
# поменяем что нибудь в первом списке
spis1.pop()
spis1.append('it works')
# проверим, что стало с третим списком, который мы скопировали правильно
print('списки: ', spis1, spis3)  # ['a', 'b', 'c', 'it works'] ['a', 'b', 'c', 'hahaha']

# еще легкий способ скопировать списки - это слайсы, они работают как и в строках
list_1 = [1, 2, 3]
list_2 = list_1[:]  # И так мы тоже создаем правильную копию списка

# В слайсах также указывается от:до:шаг
aa = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(aa[0:7])  # [0, 1, 2, 3, 4, 5, 6]
print(aa[2:8])  # [2, 3, 4, 5, 6, 7]
print(aa[0:7:2])  # [0, 2, 4, 6]
print(aa[2:])  # [2, 3, 4, 5, 6, 7, 8, 9]
print(aa[:5])  # [0, 1, 2, 3, 4]
print(aa[::-1])  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

# Циклы (loops) в python
# циклы - это повторяющееся выполнение одного и того же куска кода, выполнение, зацикленное по кругу
# while loop, выполняется, пока условие между while и : верно
x = 5
while x > 0:  # пока x > 0, будет исполняться по кругу код в блоке с отступом
    print("x: ", x)
    x = x - 1

# команда break внутри тела цикла немедленно прерывает цикл и выходит из него
# команда continue прерывает текущую итерацию (текущий проход по циклу), но цикл не останавливается
z = 5
while z > 0:
    if z == 3:
        break
    print("z: ", z)
    z = z - 1
# напишет
# z:  5
# z:  4
# и остановится по команде break

# команда continue прерывает текущую итерацию (текущий проход по циклу), но цикл не останавливается
y = 5
while y > 0:
    if y == 3:
        y = y - 1
        continue  # как только код дойдет до этой строчки, код ниже уже не сработает в текущей итерации
    print("y: ", y)
    y = y - 1
# напишет
# y:  5
# y:  4
# y:  2
# y:  1
# и остановится как обычно, после того, как условие в while перестанет удовлетворять

# Пример кода с бесконечным циклом, который постоянно запрашивает число и проверяет, четное оно или нет
# while True:
#     s = int(input("Введите число: "))
#
#     if s % 2 == 0:
#         print("Это четное число")
#     else:
#         print("Это нечетное число")


# for loop
# Цикл for используется для прохода по элементам списков и других итерируемых объектов. Рассмотрим на примере:
# создадим список, длиной в 4 элемента
sp = ['a', 'b', 'c', 'd']
# конструкцией for - in создадим цикл, который сработает 4 раза (4 - это длина нашего списка)
# при первом проходе в переменную letter подставится значение первого элемента - а, во второй раз - b, потом с и d.
# на этом цикл закончится, так как больше элементов в списке нет
for letter in sp:
    # напечатаем букву, которая в этот момент в переменной letter и эту же букву заглавную
    print('буква: ', letter, letter.upper())
# буква:  a A
# буква:  b B
# буква:  c C
# буква:  d D

# создадим еще список и цикл, который распечатает четные элементы этого списка
digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for digit in digits:
    if digit % 2 == 0:  # если делится на два без остатка, то печатаем
        print(digit)
# кострукция else есть и у for циклов и у while. Она срабатывает в конце всех проходов по циклу,
# если не было вызова команды break
else:
    print("Сюда цикл зайдет в самом конце, если не было вызова break, digit =", digit)

# результат работы этого кода:
# 0
# 2
# 4
# 6
# 8
# Сюда цикл зайдет в самом конце, если не было вызова break, digit = 9

# переменная digit, объявленная выше конструкцией for - in, также доступна и здесь, с ее последним полученным значением
print('last digit value: ', digit)
# last digit value:  9


# операторы членства
# используются, чтоб проверять, есть ли заданное значение в списке или другом итерируемом объекте
# in - возвращает True, если заданное значение содержится в объекте
# not in - возвращает True, если заданное значение НЕ содержится в объекте
ovoshi = ['kartoshka', 'morkovka', 'luk', 'pomidor']
frukti = ['yabloki', 'grushi', 'apelsini']

if 'apelsini' in ovoshi:
    print("Апельсин это овощ")
else:
    print("Апельсин это фрукт")

if 'arbuz' not in ovoshi and 'arbuz' not in frukti:
    print("Арбуз - это ягода")

# Апельсин это фрукт
# Арбуз - это ягода

mystr = 'abracadabra'  # вспомните, строка работает по принципу списка
if 'a' in mystr:
    print('Строка mystr содержит букву а', mystr.count('a'), 'раз')
    # Строка mystr содержит букву а 5 раз

# ДЗ
# необходимо использовать циклы,условные конструкции метод lower(), upper(), input(), index() и оператор %
#  !!! все задания должны выполняться с использованием циклов !!!
# 1 вывести все числа не больше 100, которые делятся на 7
# 2 запросить имя и пол 5 человек, вывести в отдельном списке мужчин, в отдельном женщин
#
# задания №3 и №4 по желанию
# 3 написать программу, которая конвертирует введенный текст в текст лесенкой
#   пример использования программы:
#   введите предложение :>? это предложение будет выведено лесенкой
#   ЭтО ПрЕдЛоЖеНиЕ БуДеТ ВыВеДеНо лЕсЕнКоЙ
# 4 проверить относится элемент списка vse к фруктам или овощам используя цикл,
#   ниже пример проверки одного элемента, без использования цикла
vse = ['kartoshka', 'smorodina', 'yabloki', 'grushi','morkovka', 'luk', 'pomidor', 'apelsini','arbuz']
ovoshi = ['kartoshka', 'morkovka', 'luk', 'pomidor']
frukti = ['yabloki', 'grushi', 'apelsini']

if 'apelsini' in ovoshi:
    print("Апельсин это овощ")
elif 'apelsini' in frukti:
    print("Апельсин это фрукт")
else:
    print("Апельсин - это ягода")
